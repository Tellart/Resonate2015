/**
 * MBLEvent.h
 * MetaWear
 *
 * Created by Stephen Schiffli on 10/8/14.
 * Copyright 2014-2015 MbientLab Inc. All rights reserved.
 *
 * IMPORTANT: Your use of this Software is limited to those specific rights
 * granted under the terms of a software license agreement between the user who
 * downloaded the software, his/her employer (which must be your employer) and
 * MbientLab Inc, (the "License").  You may not use this Software unless you
 * agree to abide by the terms of the License which can be found at
 * www.mbientlab.com/terms.  The License limits your use, and you acknowledge,
 * that the Software may be modified, copied, and distributed when used in
 * conjunction with an MbientLab Inc, product.  Other than for the foregoing
 * purpose, you may not use, reproduce, copy, prepare derivative works of,
 * modify, distribute, perform, display or sell this Software and/or its
 * documentation for any purpose.
 *
 * YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
 * PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
 * NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
 * MBIENTLAB OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE,
 * STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE
 * THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED
 * TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST
 * PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
 * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY
 * DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
 *
 * Should you have any questions regarding your right to use this Software,
 * contact MbientLab via email: hello@mbientlab.com
 */

#import <MetaWear/MBLConstants.h>
#import <MetaWear/MBLRegister.h>
#import <Bolts/Bolts.h>
@class MBLData<ResultType>;
@class MBLFilter<ResultType>;
@class MBLDataSwitch<ResultType>;
@class MBLNumericData;

NS_ASSUME_NONNULL_BEGIN

/**
 Supported Comparison filter operations
 */
typedef NS_ENUM(uint8_t, MBLComparisonOperation) {
    MBLComparisonOperationEqual = 0,
    MBLComparisonOperationNotEqual = 1,
    MBLComparisonOperationLessThan = 2,
    MBLComparisonOperationLessThanOrEqual = 3,
    MBLComparisonOperationGreaterThan = 4,
    MBLComparisonOperationGreaterThanOrEqual = 5
};

/**
 Supported Arithmetic filter operations
 */
typedef NS_ENUM(uint8_t, MBLArithmeticOperation) {
    MBLArithmeticOperationNoOp = 0,
    MBLArithmeticOperationAdd = 1,
    MBLArithmeticOperationMultiply = 2,
    MBLArithmeticOperationDivide = 3,
    MBLArithmeticOperationModulus = 4,
    MBLArithmeticOperationExponent = 5,
    MBLArithmeticOperationSquareRoot = 6,
    MBLArithmeticOperationLeftShift = 7,
    MBLArithmeticOperationRightShift = 8,
    MBLArithmeticOperationSubtract = 9,
    MBLArithmeticOperationAbsoluteValue = 10,
    MBLArithmeticOperationConstantOutput = 11
};

/**
 Pluse filter output types
 */
typedef NS_ENUM(uint8_t, MBLPulseOutput) {
    MBLPulseOutputWidth = 0,
    MBLPulseOutputArea = 1,
    MBLPulseOutputPeak = 2
};

/**
 Delta value filter output types
 */
typedef NS_ENUM(uint8_t, MBLDeltaValueOutput) {
    MBLDeltaValueOutputAbsolute = 0, // Output is Value
    MBLDeltaValueOutputDifferential = 1, // Output is Delta From Last
    MBLDeltaValueOutputBinary = 2 // Output is 1 if Increased, -1 if Decreased
};

/**
 Threshold value filter output types
 */
typedef NS_ENUM(uint8_t, MBLThresholdValueOutput) {
    MBLThresholdValueOutputAbsolute = 0, // Output is Value
    MBLThresholdValueOutputBinary = 1, // Output is 1 rising edge, -1 if falling
};

/**
 This object represents "events" generated by sensors and peripherals on the MetaWear board.
 
 There are several things you can do when an event occurs, all of which are programmable using
 this object, they are:
 
 1. Send notifications to the connected iOS device when the event occurs, see
    startNotificationsWithHandlerAsync: and stopNotificationsAsync
 2. Program other commands to be executed offline on the MetaWear device when the event occurs,
    see programCommandsToRunOnEventAsync: and eraseCommandsToRunOnEventAsync.
 3. Log the event in the MetaWear's flash storage, see startLoggingAsync and
    downloadLogAndStopLogging:handler:progressHandler:
 4. Pass the event data into a filter, which and process the data in some way and outputs the result
    in a new MBLEvent. See summationOfEvent and periodicSampleOfEvent:.
 
 ## Examples 
 Consider the switch update event, [MBLMechanicalSwitch switchUpdateEvent].
 
**Notifications**:
 
 If you call startNotificationsWithHandlerAsync: and keep a live connection to the MetaWear,
 any time you press or release the switch you will get a callback to the provided block.
 
    [device.mechanicalSwitch.switchUpdateEvent startNotificationsWithHandlerAsync:^(id obj, NSError *error) {
        // Handle the button press/release
    }];
 
 **Logging**:
 
 If you call startLoggingAsync, then anytime you press or release the button, an entry will 
 be created in the log which can be download later using downloadLogAndStopLogging:handler:progressHandler:.
 
    [device.mechanicalSwitch.switchUpdateEvent startLoggingAsync];
    // Some time later..
    [device.mechanicalSwitch.switchUpdateEvent downloadLogAndStopLogging:YES/NO handler:{...} progressHandler:{...}];
 
 **Commands**:
 
 If you want the device to buzz when you press the switch then you would do the following:
 
    [device.mechanicalSwitch.switchUpdateEvent programCommandsToRunOnEventAsync:^{
        [device.hapticBuzzer startHapticWithDutyCycle:248 pulseWidth:500 completion:nil]
    }];
 
 **Processing**:
 
 If you want to log a running count of pushbutton events, you could do the following:
 
    MBLEvent *event = [device.mechanicalSwitch.switchUpdateEvent summationOfEvent];
    [event startLoggingAsync];
    // Some time later..
    [event downloadLogAndStopLogging:YES/NO handler:{...} progressHandler:{...}];
 
 ## Gotchas
 
 @warning Calling summationOfEvent or any other filter method returns a freshly created
 MBLEvent object which you must retain for later use.  This is different from the MBLEvent
 properties on the various modules which internally save the MBLEvent object and always return
 the same pointer through the property.
 @warning Since all MBLEvent's are invalidated on disconnect, you need a way to restore your
 custom event on reconnect.  This is where the MBLRestorable comes in, you can call
 setConfiguration:handler: on the MBLMetaWear object to save any properties on your custom
 MBLRestorable object.
 */
@interface MBLEvent<ResultType> : MBLRegister

typedef void (^MBLNotificationHandler)(ResultType __nullable obj, NSError *__nullable error);

///----------------------------------
/// @name Notifications
///----------------------------------

/**
 Start receiving callbacks when this event occurs. The type of the
 object that is passed to the handler depends on the event being handled
 @param handler Block invoked when this event occus
 */
- (BFTask *)startNotificationsWithHandlerAsync:(nullable MBLNotificationHandler)handler;
/**
 Stop receiving callbacks when this event occurs, and release the block provided
 to startNotificationsWithHandlerAsync:
 */
- (BFTask *)stopNotificationsAsync;
/**
 See if this event currently has notifications enabled
 @returns YES if logging, NO otherwise
 */
- (BOOL)isNotifying;

///----------------------------------
/// @name Commands
///----------------------------------

/**
 This method is used for programing the Metawear device to perform actions
 automatically.
 
 Any time this even occurs you can have it trigger other
 Metawear API calls even when the phone isn't connected.
 When this method is called, the given block executed and checked for
 validity.  All Metawear API calls inside the block are sent to the device
 for execution later.
 @warning THE BLOCK IS ONLY EXECUTED ONCE DURNING THIS CALL AND
 NEVER AGAIN, DON'T ATTEMPT TO USE CALLBACKS INSIDE THIS BLOCK
 @param block Block consisting of API calls to make when this event occus
 */
- (BFTask *)programCommandsToRunOnEventAsync:(MBLVoidHandler)block;
/**
 Removes all commands setup when calling programCommandsToRunOnEventAsync:
 */
- (BFTask *)eraseCommandsToRunOnEventAsync;
/**
 See if this event currently has commands programmed to run
 @returns YES if has commands, NO otherwise
 */
- (BOOL)hasCommands;

///----------------------------------
/// @name Logging
///----------------------------------

/**
 Start recording notifications for this event.
 
 Each time this event occus an entry is made into non-volatile flash memory
 that is on the metawear device. This is useful for tracking things while the
 phone isn't connected to the Metawear
 */
- (BFTask *)startLoggingAsync;
/**
 Fetch contents of log from MetaWear device, and optionally turn off logging.
 
 Executes the progressHandler periodically with the progress (0.0 - 1.0),
 progressHandler will get called with 1.0 before handler is called.  The handler
 is passed an array of entries, the exact class of the entry depends on what is
 being logged.  For example, the accelerometer log returns an array of MBLAccelerometerData's
 @param stopLogging YES: Stop logging the current event, NO: Keep logging the event after download
 @param progressHandler Periodically called while log download is in progress
 */
- (BFTask<NSArray<ResultType> *> *)downloadLogAndStopLoggingAsync:(BOOL)stopLogging progressHandler:(nullable MBLFloatHandler)progressHandler;

- (BFTask<NSArray<ResultType> *> *)downloadLogAndStopLoggingAsync:(BOOL)stopLogging;

/**
 See if this event is currently being logged
 @returns YES if logging, NO otherwise
 */
- (BOOL)isLogging;


///----------------------------------
/// @name Processing Filters
///----------------------------------

/**
 Create a new event that allows input samples to pass or not. Event callbacks 
 will be provided the same object as the input.
 @param pass Initially allow samples to pass or not
 @returns New event that conditionally represents the input
 */
- (MBLDataSwitch<ResultType> *)conditionalDataSwitch:(BOOL)pass;

/**
 Create a new event that allows N input samples to pass to the output.
 After N samples, no further events will be generated. Event callbacks
 will be provided the same object as the input.
 @param initialCount Number of samples to allow through
 @returns New event representing N events of the input
 */
- (MBLDataSwitch<ResultType> *)countingDataSwitch:(uint16_t)initialCount;

/**
 Create a new event that accumulates the output data values of the current event.
 Event callbacks will be provided the same object as the input.
 @returns New event representing accumulated output
 */
- (MBLFilter<ResultType> *)summationOfEvent;

/**
 Create a new event that accumulates the number of times the current event fires.
 Event callbacks will be provided an MBLNumericData data object whose int value
 will be the number of times the input event fired.
 @returns New event representing counted intput
 */
- (MBLFilter<MBLNumericData *> *)counterOfEvent;

/**
 Create a new event that averages the output data of the current event. This
 uses a recursive average technique so the answers are approximate.
 Event callbacks will be provided the same object as the input.
 @param depth Number of samples to average (works fastest if a power of 2)
 @returns New event representing average of input
 */
- (MBLFilter<ResultType> *)averageOfEventWithDepth:(uint8_t)depth;

/**
 Create a new event that compares the current event and passes through the
 value only if the comparision is true.  Event callbacks will be provided 
 the same object as the input.
 @param op Operation type to perform
 @parma data Value on the right hand side of the operation
 @returns New event representing input values that meet the comparison condition
 */
- (MBLFilter<ResultType> *)compareEventUsingOperation:(MBLComparisonOperation)op withData:(double)data;

/**
 Create a new event that occurs at most once every period milliseconds.
 Event callbacks will be provided the same object as the input.
 @param periodInMsec Sample period in msec
 @returns New event representing periodically sampled output
 */
- (MBLFilter<ResultType> *)periodicSampleOfEvent:(uint32_t)periodInMsec;

/**
 Create a new event that represents the difference bettween the current event
 every periodInMsec milliseconds.  This acts a differential filter giving you
 the changed in value of a signal.  Event callbacks will be provided the same 
 object as the input.
 @param periodInMsec Sample period in msec
 @returns New event representing differential output
 */
- (MBLFilter<ResultType> *)differentialSampleOfEvent:(uint32_t)periodInMsec;

/**
 Create a new event that delays the current even by a given number of samples.
 Event callbacks will be provided the same object as the input.
 @param count Number of samples to delay
 @returns New event representing a delayed version of the input
 */
- (MBLFilter<ResultType> *)delayOfEventWithCount:(uint8_t)count;

/**
 Create a new event that represents a pulse of the input.  A pulse event will be
 generated when the input event crosses below threshold after first staying above
 threshold for width samples.
 If the output type is MBLPulseOutputArea or MBLPulseOutputPeak, then event 
 callbacks will be provided the same object as the input. MBLPulseOutputWidth
 output, however, will be provided MBLNumericData objects.
 @param threshold Min value considered to be a pulse
 @param width Number of samples input must stay above threshold to be considered a valid pulse
 @param output Select the type of data this filter should output
 @returns New event representing a pulse of the input
 */
- (MBLFilter *)pulseDetectorOfEventWithThreshold:(double)threshold width:(uint16_t)width output:(MBLPulseOutput)output;

/**
 Create a new event that occurs when the given event changes by a specified delta.
 If the output type is MBLDeltaValueOutputAbsolute or MBLDeltaValueOutputDifferential,
 then event callbacks will be provided the same object as the input. MBLDeltaValueOutputBinary
 output, however, will be provided MBLNumericData objects.
 @param delta Magnitude of change that must occur for event to take place
 @param output Select the type of data this filter should output
 @returns New event representing a changed of the input
 */
- (MBLFilter *)changeOfEventByDelta:(double)delta output:(MBLDeltaValueOutput)output;

/**
 Create a new event that occurs when the given event crosses a specified threshold.
 Event callbacks will be provided the same object as the input.
 @param threshold Value the event must cross for event to take place
 @param hysteresis Hysteresis on crossing to eliminate oscillation
 @param output Select the type of data this filter should output
 @returns New event representing a changed of the input
 */
- (MBLFilter<ResultType> *)changeOfEventAcrossThreshold:(double)threshold hysteresis:(double)hysteresis output:(MBLThresholdValueOutput)output;

/**
 Create a new event that occurs at the same time of this event, but whose value is
 read from the data object passed in.
 @param data Object to be read when this event occurs
 @returns New event representing the data read
 */
- (MBLEvent *)readDataOnEvent:(MBLData *)data;

@end

NS_ASSUME_NONNULL_END
